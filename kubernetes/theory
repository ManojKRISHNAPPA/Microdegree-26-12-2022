KUBERNETES OBJECT means persistence enties which are present in kubernetes systems.
we can create k objects through yaml file.
Object can be anything like...node, pod, horizontal pod autosaclaler, config map,secrets, services , namespaces
here first we create pod object...then we create service object to expose our application to the public....
 While creating object ..In that 4 fields are important..... (file name like xxxxx.yaml) called manifest file.

api version ----This tells which version of kubernetes API we are going to use to create this perticular object.

kind : It says which kind of  kubernetes object you going to create ....you want to create hpa,pod,node,service etc

metadata : This will specify unique name to our kubernetes object (this can be anything like name, name space, uid (string type)

spec : This will tell you the desired state of the kubernetes object.....
for ex  :if i create pod object then desired state includes docker image , port number etc

Once installed minikube you can delete it...and wen you want to  use it again just type minikube start
---
----
----
---

till you see the message kubectl configured......
after that you can start using minikube

kubectl get nodes

namespaces: It is k8s object..which is used for a kind of mechanism for isolating the gropup of resources within a cluster.
It is nothing but your projects....If you want to create staging , developeent environment for your oraganisation in a single 
cluster then you can use a namespaces.
(here one or more devops engineer will wok in single k8 cluster....developer will give the application A 's  code   to devops engineer.1 ...
He will dockerise that application and build a docker image of that application. 
And then he will dploy this applicatopn on a kubernetes cluster as a pod. And then he runs as a container. 
And in menifest file , he used metadata xyz and deployed that application.
Devops engineer.2 will do the same thing and he deploy his application in the same k8 ncluster....He also used same metadata name in his 
menifest file....So application is updated....That means the application delerted , which is deployed from devops engineer 1 and
devops engiineer 2's application is updated.
#rd devops engineer also did the same thing...
That means they all deployed under same name spaces...and all names overwrite
So in real time multiple people will working on a same project...to avoid all these namespace is  created.
in same name space we cant use same metadata...in different name space we can use same metadata.....

kubectl get ns

kube- default (our  kubernetes cluster will set in default namespace...If you do any deployment without specifieng name 
space that is go and deployed on this default namespace...This is the name space where kubernetes provide for  you to start 
deploying your k8s objects or resources here in default name spaces.

kube node-lease --This is going to tell you that wether your node is up and running or not. if not it will send a signal to controller manager.
kube-public --- This is publically accesible...Our client can access the kubernetes cluster throgh this namespace
kube-system -----Here Kubernetes services which is related to this perticular k8s cluster can run here (i.e kube etcd kube shedular cm,cube proxy 
such perticular pods are running here..because those are system level service. 
That is been reserverd for the system level services to be running

In future dont touch other name spaces except default....or your own custom name spaces.....

In minikube:

kubectl create ns bhavya
kubectl get ns
So in our name space we will create kubernetes objects.

Next day topic:
minikube start
Pods object:

Pods are nothing but containers....Containers are running applications.....

kubectl get pods
kubectl get ns
ls
mkdir kube
cd kube
ls
vim deployment.yaml

apiversion: v1
kind: pod
metadata:
 name: my-app 
spec:
  containers:
  - name: my-app
    image: nginx
    ports:
     - containerport: 80                      (here p is capital)
:wq!

kubectl apply -f deployment.yaml
====pod my-app created
kubectl get pods
========pod is running and this pod is nothing but containers.....containers are nothing but appluication....intern pod has one application...
So inorder to access this perticular application i need to have a perticular kubernetes services running for this perticular pod.
then only we can expose this application to the outside world.

So here in thus minikube we can not create services...because minikube has its own limitation....it is minimal in size.....
So we can not create kubernetes service object here....this we can achive in real time k8s cluster.

deployment object: This is going to create a pod...also create a replication controller...or replication sets.

Here we can create replicas of same docker image....But in pod object we cant create replicas of same image....
If we need replicas then we have to deploy our object as a deployment objects....hete vthere is provision for replicas.....

we can use previous script....
mv deployment.yaml pod.yaml
ls
===pod.yaml(previous deployment .yaml name changed to pod.yaml)
now lets write deployment file for deployment object....


vi deployment.yaml

apiversion: apps/v1
kind: Deployment
metadata: 
  name: vins
  labels:
     app: vins
spec:
  replicas: 2
  selector:
    matchLabels:     ===== llabels L should be capital
      app: vins
  template:
    metadata:
      labels:
        app: vins
    spec: 
      containrs:
      - name: vins
        image: nginx
        ports: 
        - containerPort: 80       =======Port P should be capital

save and exit
kubectl apply -f deployment.yaml
======deployment objects created

kubectl get pods
 ======== myapp  
           vins  yyyyyyyyyyyyyyyyyyy  xxxxxxxxx   
           vins   yyyyyyyyyyyyyyyyyy   zzzzzzzzzzz

here myapp  ------> pod object
vins   -----------> dep object
yyyyyyyyyyyyyyyy ----------> deployment  id
xxxxxxxx   and  zzzzzzzzzz  --------------> replica id
vins  yyyyyyyyyyyyyyyyyyy  xxxxxxxxx   ------------ deployment object  and it is called pod name....

To delete this   
kubectl delete pod vins  yyyyyyyyyyyyyyyyyyy  xxxxxxxxx   
======> pods deleted

BUT if you check kubectl get pods=====>
three are there......

But if you delete pod object it will delete....
kubectl delete pod myapp
=======> it will delete


There is senarioa where i have deployed a pod...accidentially that pod got deleted...but still i see that pod is getting created
often and often....why is it so?
How to delete that pod permanently?

Is that pod being deployed as a deploymrnt object or a normal pod???? if it is a normal pod it should get deleted...
because it doesnt have a functionality of the pod getting often and often recreated.......
If it is getting recreated it shoud have been deployed as a kubernetes deployment object.
Inorder to delete that pod we have to delete that deployment object itself....otherwise pods well be keeps on recreating....
To delete that kubectl delete deployment deployment name ......This much is the ans.


Now to know deployment 
kubctl get deployments
====> you can see the name of the deployment.


kubectl get pods

To see complete pod information:

kubectl describe pod podname

if i want to delete object itself
kubectl delete -f deployment.yaml   
  
or

kubectl delete deployment vins  ======(vins is the deployment name)


kubectl get pods


deleted

Till here we used to deploy public images from the docker registry...
Now lets use private images.... using image from  https://hub.docker.com/r/vinaytr/test-evng-batch123/tags
 Now do
vi deployment.yaml
in that image : vinaytr/test-evng-batch123:v1.23
save and exit
kubectl apply -f deployment.yaml
========>deployment apps created....
kubectl get pods
=======>here you can see eror in status

To check what error =====> type
kubectl describe pod podname
Here it is telling that since it is private image we need to configure kubernetes secres object through a command...not in yaml file...

kubectl create secret docker-registry my-secret --docker-server=https://index.docker.io/v1/ --docker-username=vinaytr --docker-password= --docker-email=vinay.t59@gmail.com


secret-my-secret is created
vim deployment.yaml
 just add below lines below containerPort :80
i.e

apiversion: apps/v1
kind: Deployment
metadata: 
  name: vins
  labels:
     app: vins
spec:
  replicas: 2
  selector:
    matchLabels:     ===== llabels L should be capital
      app: vins
  template:
    metadata:
      labels:
        app: vins
    spec: 
      containrs:
      - name: vins
        image: nginx
        ports: 
        - containerPort: 80 
      imagepullsecrets:    ========= p and s should be capital
      - name: my-secret

save and exit


kubectl get secrets
kubectl get pods
kubectl delete deployments vins

kubectl apply -f deployment.yaml
kubectl get pods

